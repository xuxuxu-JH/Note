# C#面试题
***
## 装箱拆箱
装箱:值转引用
拆箱:引用转值
无论是装箱还是拆箱,都会涉及到堆,栈这两个内存中的内容迁移,会有性能消耗
* 如何避免装箱拆箱?
	* 使用泛型<T>
	* 使用 var 弱类型
	* 使用is as,is进行类型检查,as用于安全的类型转换
## 值和引用类型在变量的区别是什么？
1. 值类型存储在栈,引用类型本身的实际数据存储在堆中,栈中存放的是一个引用的地址
2. 值类型的内存是自动管理释放的,堆内存由GC垃圾回收进行管理
使用赋值上的区别:
值类型是拷贝赋值,a和b的值修改互不影响
举例:
```csharp
int a = 10;
int b = a; // 将a的值复制到b
b = 20; // 修改b不会影响a
Console.WriteLine(a); // 输出10
Console.WriteLine(b); // 输出20
```
引用类型的变量赋值给另一个变量时，两个变量将引用相同的对象，它们指向相同的内存位置。
修改一个变量可能会影响另一个变量，因为它们共享相同的对象。
举例:
```csharp
List<int> list1 = new List<int> { 1, 2, 3 };
List<int> list2 = list1; // list2引用了与list1相同的列表对象
list2.Add(4); // 修改list2也会影响list1
Console.WriteLine(string.Join(", ", list1)); // 输出1, 2, 3, 4
Console.WriteLine(string.Join(", ", list2)); // 输出1, 2, 3, 4
```
## 委托和事件
* 委托
委托是装载和传递函数的容器,委托类型和注册该委托的函数的类型必须一致(返回值,参数等)
委托可以作为函数的参数来进行传递
* 事件
事件是基于委托的基础上进行声明的
事件是一种特殊的委托,相比委托更加安全，只能在内部触发,外部赋值,不能像委托一样直接用等号`=`进行赋值,只能通过`+=` 或` -= `绑定和取消注册事件中的函数
事件通常用于观察者模式
## C#中的List本质是什么?List是如何进行扩容的?
1. List的底层实现是一个动态数组,C#封装了这个数组并提供了一些方法和功能,比如:增删改查
2. List在初始化时,会提供一个默认的容量,当元素Count等于List容量时,会进行扩容操作,一般是扩大当前容量的两倍,然后将现有的数组元素,迁移到新创建扩容的数组当中去,改变数组对象的引用
随着扩容次数增加,List的容量会越来越大,后续再次扩容的次数就会变少,间接的减缓了GC的次数,提高了性能
## GC垃圾回收
简单概括GC的过程:
每次new一个对象的时候,遍历堆内存上动态分配的所有对象,判断那些对象未被任何引用,这些未被引用的对象就是垃圾,需要被回收释放
GC只负责堆内存上的垃圾回收,
**GC原理:**
* C#中的垃圾回收机制会采用一种分代算法,将内存分为0,1,2三代内存
* 新分配的对象会在0代内存当中,每次新分配对象时都会检查内存是否满了,当0代内存满时,会进行垃圾回收,在垃圾回收开始时,会进行以下操作:
	1. 标记对象,从根部检查那些是可达和不可达对象,被引用的就是可达对象,未引用就是不可达对象,这些不可达对象就会被视为垃圾,释放这些垃圾
	2. 释放这些垃圾后,将这些可达对象搬迁到1代内存当中去,修改为连续的引用地址
	3. 当1代满了,再次触发垃圾回收,并且会将0,1一起释放,无论是几代都会将之前的n代内存一起释放,再次搬迁
	因此,GC是一个极其耗费时间的操作,堆内存上的变量或者引用越多就会导致在遍历的时候操作十分缓慢
## 结构体和类的区别
1. 结构体是值类型(堆),类是引用类型(栈)
2. 在C#中定义结构体的时,结构体内部的成员是不能够被初始化的,结构体的成员需要再构造函数中全部初始化,定义类的时候可以初始话类内部的成员变量
3. 结构体不能声明无参构造函数,但是类可以,结构体中的构造函数需要初始化其中的所有成员
4. 结构体不能被继承,类可以
5. 结构体不能被static修饰,类可以
## `==`和`Equals`的区别?
1. `==`是运算符,`Equals`是Object类中的虚方法,可以被重写
2. 根据类型的不同,两者的比较方式不同
	* 对于值类型: `Equals` 和 `== `一样,都是比较栈中的值是否相等
	* 对于引用类型: `Equals`比较的是两个对象在堆中的内容是否相同, `== `比较的是引用的地址
	* `==`比`Equals`的执行效率会更高,`Equals`中比较的内容会更多
## 浅拷贝和深拷贝的区别？举例说明
* 浅拷贝
	* 浅拷贝是指创建一个新对象,然后将原对象的字段值复制给新的对象,但是对于引用类型,复制是引用而不是对象本身,当两个引用类型的对象共享同一个引用的时候,其中一个的对象修改了值,另一个会受到影响
* 深拷贝
	* 深拷贝是复制原对象当中的所有内容,包含数据本身,而不是简单的复制引用,这样在赋值之后,两个对象的数据都是相互独立的,互不干扰
* 举例:
	* 修改int 和 List 的区别,最简单的深拷贝就是new一个新对象
## 泛型的约束有几种?
1. 值类型约束 T:struct
2. 引用类型约束(类,接口) T:class
3. 公共无参构造约束 T:new()
4. 另一个泛型约束 T:U(另一个泛型的占位符)
## 什么是闭包?请举例说明
闭包一般是函数嵌套,内部的函数能够有权限访问外部函数作用域中的局部变量
使用Lambda表达式(匿名函数)来实现一个闭包
```c#
class Test2
    {
        //一个函数 返回值是委托类型
        public Action<string?> CreateWrite()
        {
            string msg = "";
            //返回一个和委托类型一致的匿名函数
            return (string? info) =>
            {
                //如果info为空 msg = msg 
                //如果info不为空 mag = info
                //当info为空的情况下,内部的匿名函数使用了外部的局部变量 msg 这就形成了一个闭包
                msg = info ?? msg;
                System.Console.WriteLine(msg);
            };
        }
    }
```
## 抽象类和接口的区别？
1. abstaract用来定义一个类，interface用来定义一个接口
	* 相同点：
		* 都可以被继承，抽象类中的抽象部分交给子类实现，接口中的定义的所有都由子类实现
		* 都不能被直接实例化
	* 不同点：
		* 抽象类中可以有实现成员,接口只能有抽象成员;因此接口是完全抽象,抽象类是部分抽象
		* 抽象类中既可以做方法的声明,也可以做方法的实现;接口中只能做方法的声明
		* 接口可以实现多继承,抽象类不支持
		* 抽象类中可以有构造函数，接口中没有

## 内存泄漏指什么？常见的内存泄漏有哪些？
* 程序运行过程中，由于程序未正确释放不再使用的内存，导致系统中的可用内存逐渐减少
	* 常见的内存泄漏的情况有:
	1. 过多的静态对象
	2. 对象没有被及时的置为null
	3. 文件操作时,没有使用using或者进行Dispose()
	4. 委托当中的函数没有被及时的 -=
## 游戏中的成就系统，我们一般会使用设计模式中的哪种模式来制作？
观察者,比如收集一个物品可能会同时达成多个成就,这时只需监听收集物品数量这个事件,当物品数量达成后,通知其他所有的观察者
## 观察者设计模式
在观察者设计模式中，主要包括两个部分的内容，被观察的对象和观察者；通常使用一个观察者列表来维护这些观察者，对观察者进行增删的操作和通知所有的观察者，因此事件(或者用List)就可以作为观察者列表来使用，在使用观察者设计模式的时候，通常会监听一个观察者的一个属性，也就是触发的条件，可以是某个变量的值的变化，当满足触发条件的时候，调用event，所有注册了这个event的观察者就要执行各自的行为，同时我们可以用接口规范这些观察者行为，去做同一件事
## 请说明以下字符串的区别
```C#
1. string str = null
2. string str = ""
3. string str = string.Empty
```
* str = null 在堆内存中没有分配地址
* 2 和 3 在堆中都分配了内存,字符内容是空字符
* string.Empty是一个静态只读变量
## String 和 StringBuilder
* string是一种特殊的引用类型,具有部分值类型的特征
* string对象本身是不支持修改的,对string的任何一次修改实际上是创建新的字符串对象然后迁移过去,因此频繁的修改string会产生较多的垃圾,浪费内存,为了提高性能,使用StringBuilder来替代
* StringBuilder的原理是内部维护了一个char类型的动态数组,当我们new一个StringBuilder对象时,会开辟一个固定大小的空间,对SB对象进行操作时,实际上是对SB内部的数组进行操作,当数组空间不够的时候才会进行扩容,避免了string的重复创建和销毁
* 虽然SB的内存性能更好,但是String类有很多的函数可以调用,包含更方便的方法
## C#中的Action和Func是什么？Unity中的UnityAction是什么？他们有什么区别？
1. 都是已经写好提供给我们能够直接使用的委托,它们都支持泛型
2. Action无参返回值 Func有参有返回值
3. UnityAction 本身是一个无参无返回值的委托
## C#中Dictionary中如何实现一键多值?
思路:用容器存放多个值,具体用什么数据结构来存,视需求而定
比如Value可以用:List,Array,LinkedList,Stack,Queue
## 内存中,堆和栈的区别是什么?
* 由操作系统自动分配释放，存放函数的参数值，局部变量值，栈中数据的生命周期随着函数的执行完成而结束
* 一般由程序员分配释放，如果开发人员不释放，程序结束时由操作系统回收
（在C#中 托管堆内存 会由 C#帮助我们管理，存在GC垃圾回收机制）
## C#中new关键字的作用（至少说出3种）
1. 实例化创建新的对象
2. 子类函数声明时加上new关键字，可以隐藏掉父类方法
3. 泛型约束中使用new关键词，表示需要无参构造
## 回调函数指什么？一般在什么时候使用？（至少说出3种使用场景）
* 回调函数指的是该函数作为函数的参数进行传递,被别的函数调用,就是回调函数
* 在C#中以委托的形式出现,
使用场景:
1. 异步编程:异步逻辑执行完毕后，再执行回调函数
2. 事件响应,当某个事件触发,立刻调用这个回调函数
## 单例模式作用，使用单例和只创建一个static对象的区别
* 单例模式的主要作用是:确保一个类只有一个能够访问的对象,且这个对象能够在全局进行访问,单例对象是在内部进行实例化的,外部直接获取该对象,避免重复创建对象
* 静态对象不需要进行实例化,直接通过类名来反问,静态对象的生命周期和程序共生共死(详解static的特点)
* 另外静态类不适用与面向对象,更多的是作为工具类来使用
## 什么是匿名函数？匿名函数一般用在哪？ 什么使用使用具体命名的函数,什么时候使用匿名函数?
* 没有函数名,使用lambda表达式进行表示的函数
* 匿名函数通常作为一次性使用或短时间内使用
* 作为其他函数的参数进行传递
* 闭包
## 1.在自定义类中声明的成员变量，类型为int，该int变量存储在栈上还是堆上？2.在自定义结构体中声明的成员变量，类型为string，该string变量存储在栈上还是堆上？
1. 存储在堆上,自定义类当中无论声明的变量是什么类型都存储在堆上,因为类本身存储在堆
2. 存储在堆上,如果是结构体变量中的声明了一个引用类型的对象,实际上这个引用对象存储在堆上,结构体的内部存储的是这个对象的引用地址
## C#中在什么情况下会选择使用接口，什么情况下会选择使用抽象类？
* 接口:不同对象的共同行为,实现多态,需要多继承
* 抽象类: 同类对象的共同行为,因为抽象类中可以包含非抽象成员,共享成员变量

